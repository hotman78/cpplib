--一文字固定 or 答えを決め打ち
    最大の最小化は二分探索
    f(s,t)の最大化はs,tのどちらかを固定 r-l,s+t等
    k=∑a/∑bと置く
    
--ゲーム
    状態数に対して線形でいいならメモ化再帰(無理にDPしようとしない)

--数学
    階段状にして考える
    ∑S_i*A_i=∑((S_{i+1}-S_i)*(∑B_i))

--操作系
    逆から見る

--計算量解析
    ∑_{i=0}^{N}(N/i)=O(NlogN)
    素数だけ見ればいいならO(NloglogN)
    見るたびに見るべきものが半分以下になるなら線形
    1個の物が何回見られるかで評価(償却時間で評価)
    (例)1個ずつ追加され、そのたびに
    木DPは愚直のオーダーが落ちがち
    要素数N,M(N<M)として

    O(N*M)でO(N+M)個にマージできるなら、全体でO(N^2)
    証明:
    集合Sと集合Tをマージする時、集合Sと集合Tの各要素間に辺を引くとO(|S|*|T|)
    集合が1つになった時最終的な辺の数はN*(N-1)/2(完全グラフなので)
    snukeさんブログ参照

    O(Nf(N+M))でO(N+M)個にマージできるなら、全体でO(Nf(N)logN)
    一回見られると所属する集合のサイズが2倍以上になるので高々O(logN)しか見られないため
    (参考:るまブログ)
    小さい順にマージできるならO(N+M)でO(N+M)にマージしてもO(Nf(N)logN)
    証明:
    NをMとマージしN+MをLとマージしたとすると
    N+M+L>=2*M
    M<=LよりM+L>=2*M
    よってO(M)=O(N+M)より2回マージすると2倍以上になる
    (参考:るまブログ)

--数え上げ
    余事象を考える(どちらか一つに固執しすぎない)
--文字列
    O(|S||T|)のDPは頻出
    SA,Zアルゴ,ロリハを頭に置く
    無理にsuffix automatonを使おうとしない
    ワイルドカード有りの一致判定は畳み込みでアプローチできるがO(n^2)で大丈夫なら使わない